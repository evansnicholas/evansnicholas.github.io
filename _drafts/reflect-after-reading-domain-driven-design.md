---
layout: post
title: Reflect after Reading - Domain Driven Design
---

If you knew nothing about it, you could be forgiven for thinking that *Domain Driven Design: Tackling Complexity in the Heart Of Software* by Eric Evans was selling a Methodology.  The kind that is described (and derided) in *Peopleware* as "a general systems theory of how a whole class of thought-intensive work ought to be conducted".  It ticks the boxes: it comes in a big fat book, you can take courses in it, and it claims to solve your software development woes once and for all...

...Or does it?  *Domain Driven Design* ends by quoting Christopher Alexander, the architect-philosopher who also influenced the *Peopleware* authors.  Alexander argues that successful building projects are a result of "piecemeal growth" and "organic order" rather than the logical conclusion of a "master plan".  Just like the *Peopleware* authors, Evans believes this conclusion is also applicable to the field of software engineering.  In *Domain Driven Design* Evans takes great care to avoid creating the illusion that DDD is a golden recipe for success (or even that it is a recipe at all).  Instead, the book is a very subtle and detailed exposition of a certain "attidude" that, when used to guide the development process, can lead to the creation of enterprise scale software that exhibits the "organic order" Alexander sought in his architectural projects.  

Domain Driven Design is a deep reflection on the process of software development, and the conclusions it reaches can be characterized as a philosophy: a way of thinking about and practicing software engineering.  These conclusions are structured into "analysis patterns" and illustrated with detailed examples from Evans' career as a software engineer.  DDD is 10 years old and still relevant (amazing for the software industry!), despite the fact it emerged from a world when object oriented programming was all the rage, Extreme Programming didn't feel like a gimmick and the answer to every data persistence question was "relational database". It is testimony to the depth of the insights in DDD that in a world dominated by microservices, functional programming and NoSQL databases it continues to strive and help developers structure complex software projects. 

## The philosophy
The core concept in the DDD philosophy is the *domain model*.  In the glossary, a model is defined as "a system of abstractions that describes selected aspects of a domain and can be used to solve problems related to that domain".  An immediate question is what concrete form does this model take?  How is this "system of abstractions" expressed?  Is it contained in a modelling tool?  Is it described in documentation?  Is it the code itself?  While all of these can help shape the model, the most important expression of the model in DDD is the *ubiquitous language*.  This is the language used by the development team when discussing their ideas about the software.  It is the language that is employed when communicating with domain experts.  It provides the vocabulary for naming classes and methods in the software itself.  In DDD, the model does not have a canonical expression, but instead permeates every aspect of the software development process.  

Using and working with the model takes discipline.  Developers have to pay close attention to their use of language, and extract the model from conversations with domain experts.  The ultimate goal of a team applying DDD is to arrive at what Evans refers to as a *deep model*, expressed in code through the application of *supple design*.  A deep model can be said to "carve nature at the joints" (in Plato's words), or as Evans puts it, follows the "conceptual contours" of the domain.  A deep model provides a representation of the domain that enables rich applications to be built with relative ease.  It allows new functionality to slot in beside existing functionality.  Changing requirements can be accomodated without a complete rethink of the application structure.  In keeping with the teachings of Agile and Extreme Programming (XP), a deep model is arrived at through numerous iterations and refactorings.  Furthermore, Evans describes how a process of "distillation" allows the development team to strip the model of superflous elements and reduce it to its core.  During the development process, the team must keep a close tab on the evolution of the ubiquitous language and ensure that any changes are reflected in the code (and documentation).  Furthermore, any difficulty or awkwardness experienced during development should be taken as a hint that the model needs to be adjusted.  Through this process of constant refinement, a team can produce a deep model that provides real value to the business. 

## The patterns

In order to help developers arrive at a deep model, Evans suggests several patterns that can be used to structure the software.  These patterns are abstract enough to be applicable to a variety of domains, yet precise enough to be useful.  The patterns can broadly be divided into two categories, depending on the level of abstraction at which they are applicable.  The first category contains patterns that are applicable at the level of objects and classes.  In this sense they are similar to the "gang of four" design patterns.  The patterns in the second category form the basis for what Evans refers to as "strategic design".  These are applicable at a much higher level of abstraction and are intended to help structure software at the level of an entire enterprise.  Although this sounds worryingly over-ambitious, one of the fundamental principles of strategic design is that all-encompassing models are impossible to create.  For this reason, structure at the level of the enterprise relies on carving up the software into "bounded contexts" and defining clearly how these contexts interact.  I have gathered a small selection of the most memorable patterns.  In the book all these patterns are illustrated by detailed examples.

<small>**ENTITY**</small> An element of the model that has long lasting identity, for instance a Customer in a typical CRM tool.  Throughout its lifecycle, an entity may be represented in memory by different objects at different times.  For entities, special care must be taken when trying to identify them in terms of their characteristics.  For instance, the "name" field is not a good way to identify a customer (many customers are likely to have the same name).

<small>**AGGREGATE**</small> A class representing an entity will often participate in relationships with other classes.  These networks of classes maintain application state that must often also respect certain invariants: an update to a certain part of the model entails an update to another part as well.  In order to make these dependencies manageable, Evans introduces the *aggregate* pattern.  An aggregate is a collection of interrelated classes whose state is governed by certain invariants.  All updates to the aggregate must go through a certain special class referred to as the *aggregate root*.  This class is responsible for orchestrating state updates in such a way that invariants are never violated.  Because all updates must go through the aggregate root, the state of the aggregate is shielded from incorrect use by possible clients.

<small>**VALUE OBJECT**</small> A class that is the collection of its attributes.  Two value objects are equal when all their attributes are equal (in the Scala programming language case classes are the perfect tool for representing value objects).  These combine particularly well with the next pattern.

<small>**SIDE EFFECT FREE FUNCTION**</small> A function that computes its result without performing any side effects.  In the functional programming community this type of function is also called a "pure function".  Pure functions are desirable because they are easy to reason about.  The result they produce is a function (in the mathematical sense) of their input.  Using value objects as the paramaters and return value of a side effect free function makes for clean and elegant code.  Side effect free functions are also easy to unit test.

<small>**BOUNDED CONTEXT**</small> The core pattern in terms of which the other strategic design patterns are expressed.  A bounded context is a coherent model that stands on its own and is isolated from other models.  When creating a very large application it will be impossible to capture all aspects of the domain in the same model.  Nevertheless, different parts of the application (different contexts) will overlap in their coverage of the domain.  Although good software engineering practice would seem to point towards model re-use as much as possible, Evans shows that careless model sharing can lead to great difficulties.  For this reason, drawing a clear "context map" and thinking clearly about the relationships between the models used by different parts of the application is crucial to creating software that can scale conceptually to cover the domain of a large enterprise.

## The future (the present)

It is remarkable to note that DDD has managed to stay in the tech industry's consciousness for over ten years.  This is a sign that the insight it offers is of significant value.  In his interview with software engineering radio, Evans reflects on the evolution of DDD, and the applicability of its concepts in today's tech landscape.  In particular, he discusses the following subjects: microservices, event sourcing/CQRS (Command Query Responsibility Segregation), functional programming, the actor model and NoSQL.

<small>**MICROSERVICES**</small> Evans explains that in the early days of DDD there was no technical support for implementing bounded contexts.  It was down to the discipline of development teams to ensure that their models were kept clean and had clear relationships with the models of other teams.  Microservices solve this problem by providing clear boundaries for the validity of a model.  Microservices are meant to be standalone and sealed off from their environment, communicating with other services through a well defined interface.  Interestingly, Evans equates a bounded service with a cluster of microservices rather than with a single one.  The microservices within such a cluster speak the same language and therefore can communicately effortlessly with each other.  Special care is needed to provide appropriate translation when a microservice from one bounded context calls a microservice from a different bounded context.  Structuring a code base into microservices forces developers to think about the boundaries within which their model is applicable.

<small>**EVENT SOURCING/CQRS**</small> Event sourcing and CQRS are two architectural styles that were developed by DDD practioners searching for better modelling strategies.  Precisely because they were focused on finding the best way to express the core concepts of the domain in their software, these practioners were led beyond the patterns that Evans presents in his book to discover ones of their own.  The key insight that inspired these approaches was that instead of focussing on *state*, a domain model should be structured around *state change*.  State is then reconstructed from state change by "rolling up" a sequence of changes.  State changes are immutable, which means they are better suited for supporting a scalable distributed system.  They also match well with the fundamental principles of functional programming...

<small>**FUNCTIONAL PROGRAMMING**</small> Immutability and pure functions are two fundamental principles of functional programming.  We have already seen that DDD can be made to work with immutable domain objects by applying the modelling techniques of event sourcing.  As for pure functions, we saw in the previous section that they are already an important pattern within DDD.

<small>**ACTOR MODEL**</small> The actor model is a way of structuring programs to make them easy to execute in parallel over distributed computing resources.  Akka is a popular implementation of the actor model in the Scala programming language.  In this context, the aggregate pattern gains a new lease of life.  The principle motivation behind the aggregate pattern was to provide a mechanism to ensure that application state did not become corrupted by incomplete updates.  In the context of the actor model, an aggregate can be implemented by a group of actors managed by one actor which represents the aggregate root.  This root actor is reponsible for receiving any messages from the application and then updating its child actors appropriately.  Because actors are completely shielded from each other and cannot access each other's state, the actor model is a very appropriate technical basis for implementing the aggregate pattern. 

<small>**NOSQL**</small> Although Evans concedes that the catalyst for the emergence of NoSQL datastores was improved performance, he explains that their most important contribution is actually the introduction of new modelling techniques to the database realm.  He suggests that NoSQL should actually be read as an acronym for "Not Only SQL".  At the time DDD was written, the only way to persist data was in a relational database.  Although this model is applicable in many cases, it is not always a good fit.  The emergence of graph databases, column databases, key-value stores etc... has given developers must more freedom in choosing a persistence technology that follows the conceptual contours of the domain in which they working. 


* * *

### References
- 10 years of DDD [interview](http://www.se-radio.net/2015/05/se-radio-episode-226-eric-evans-on-domain-driven-design-at-10-years/) with Eric Evans
- [Peopleware](http://www.amazon.com/Peopleware-Productive-Projects-Second-Edition/dp/0932633439)